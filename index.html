<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Tilemap Tutorial 4</title>
</head>
<body>
	<div id="game-div"></div>
</body>
<script src="vendors.bundle.js"></script>
<script src="app.bundle.js"></script>


<!-- tutorial for matter. VERY good! -->
<!-- <script src="//cdn.jsdelivr.net/npm/matter-js@0.14.2/build/matter.js"></script>
<script>
	document.addEventListener("DOMContentLoaded", () => {
		console.log('onload done')
		const {Engine, Render, World, Bodies, Body} = Matter;
		const DEGREES_TO_RADIANS = Math.PI / 180 //helper constant to convert radians to degrees

		console.log(Engine);
		console.log(Render);
		console.log(World);
		console.log(Bodies);
		console.log(Body);

		const engine = Engine.create();
		const render = Render.create({
			element: document.getElementById("game-div"),
			engine: engine,
			options: {
				width: 800,
				height: 600,
				wireframes: false,
				background: "#f4f4f8"
			}
		});
		
		/*
		// Create a rectangle centered at the top of the screen, (400, 0), with 120px width and 80px height
		const rectangle = Bodies.rectangle(400, 0, 120, 80, {restitution: 0.0, angle: Math.PI/4});

		// Create an immovable rectangle at the bottom of the screen that will act as the floor
		const floor = Bodies.rectangle(400, 575, 800, 50, {isStatic: true});

		// Add the newly minted bodies to our physics simulation
		World.add(engine.world, [rectangle, floor]);

		// Kick off the simulation and the render loops
		Engine.run(engine);
		Render.run(render);
		*/




		// Create some simple physics bodies, horizontally centered & above the top edge of the canvas
		var rectangle = Bodies.rectangle(400, -300, 120, 80, {friction: 1, restitution: 0.25});
		var circle = Bodies.circle(400, -150, 50, {friction: 0, restitution: 1});

		// Polygon parameters: x, y, number of sides, radius of the shape, body options. A three-sided
		// polygon will give us a triangle.
		var triangle = Bodies.polygon(400, 0, 3, 50, {friction: 0, restitution: 0.5});

		// Create an immovable rectangle at the bottom of the screen that will act as the floor
		var floor = Bodies.rectangle(400, 575, 800, 50, {isStatic: true});

		// Create some vertical walls that are positioned just off screen.
		var leftWall = Bodies.rectangle(0, 300, 50, 600, {isStatic: true});
		var rightWall = Bodies.rectangle(800, 300, 50, 600, {isStatic: true});

		// Create some bouncy, static obstacles in the world for our bodies to ricochet off of
		var obstacle1 = Bodies.circle(150, 200, 85, {isStatic: true, friction: 0, restitution: 1});
		var obstacle2 = Bodies.polygon(400, 400, 3, 75, {
			isStatic: true,
			angle: 90 * DEGREES_TO_RADIANS,
			friction: 0,
			restitution: 1
		});
		
		var obstacle3 = Bodies.circle(650, 200, 85, {isStatic: true, friction: 0, restitution: 1});


		//cross
		var verticalPart = Bodies.rectangle(400, 150, 100, 50);
		var horizontalPart = Bodies.rectangle(400, 150, 50, 100);
		var cross = Body.create({
			parts: [verticalPart, horizontalPart],
			friction: 0,
			restitution: 0.9
		})

		//some helper functions for clicking
		var randomInRange = (min, max) => Math.random() * (max - min) + min;
		var randomIntInRange = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);

		//clicking
		document.querySelector("canvas").addEventListener("mousedown", () => {
			for(var i = 0; i < 5; i++)
			{
				var x = randomInRange(50, 750);
				var y = randomInRange(0, 50);
				var radius = randomInRange(25, 50);
				var sides = randomIntInRange(3, 6);
				const body = Bodies.polygon(x, y, sides, radius, {
					friction: -1,
					restitution: 0.5
				});
				
				World.add(engine.world, body);
			}
		})

		World.add(engine.world, [
		rectangle,
		triangle,
		circle,
		floor,
		leftWall,
		rightWall,
		obstacle1,
		obstacle2,
		obstacle3,
		cross
		]);

		Engine.run(engine);
		Render.run(render);




	});
</script> -->

</html>